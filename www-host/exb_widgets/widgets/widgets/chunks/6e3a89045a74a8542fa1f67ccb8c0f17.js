"use strict";(self.webpackChunkexb_client=self.webpackChunkexb_client||[]).push([[8015],{50516:(e,a,t)=>{t.d(a,{D:()=>n});var r=t(71760);function n(e){e?.writtenProperties&&e.writtenProperties.forEach((({target:e,propName:a,newOrigin:t})=>{(0,r.l)(e)&&t&&e.originOf(a)!==t&&e.updateOrigin(a,t)}))}},71760:(e,a,t)=>{function r(e){return e&&"getAtOrigin"in e&&"originOf"in e}t.d(a,{l:()=>r})},8015:(e,a,t)=>{t.r(a),t.d(a,{save:()=>x,saveAll:()=>Z,saveAllAs:()=>A,saveAs:()=>D});var r=t(7753),n=t(70375),i=t(50516),l=t(21011),o=t(20692),s=t(8308),u=t(54957),c=t(92557),y=t(84513),d=t(31370);const p="Feature Service",f="feature-layer-utils",m=`${f}-save`,w=`${f}-save-as`,h=`${f}-saveall`,b=`${f}-saveall-as`;function v(e){return{isValid:(0,u.fP)(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function L(e){const a=[],t=[];for(const{layer:r,layerJSON:n}of e)r.isTable?t.push(n):a.push(n);return{layers:a,tables:t}}function g(e){return L([e])}async function I(e,a){return/\/\d+\/?$/.test(e.url)?g(a[0]):P(a,e)}async function P(e,a){if(!a)return e.reverse(),L(e);const{layer:{url:t,customParameters:r,apiKey:n}}=e[0];let i=await a.fetchData("json");null!=i?.layers&&null!=i?.tables||(i=await async function(e,a,t){e||={},e.layers||=[],e.tables||=[];const{url:r,customParameters:n,apiKey:i}=a,{serviceJSON:l,layersJSON:o}=await(0,s.V)(r,{customParameters:n,apiKey:i}),u=S(e.layers,l.layers,t),y=S(e.tables,l.tables,t);e.layers=u.itemResources,e.tables=y.itemResources;const d=[...u.added,...y.added],p=o?[...o.layers,...o.tables]:[];return await async function(e,a,t,r){const n=await async function(e){const a=[];e.forEach((({type:e})=>{const t=function(e){let a;switch(e){case"Feature Layer":case"Table":a="FeatureLayer";break;case"Oriented Imagery Layer":a="OrientedImageryLayer"}return a}(e),r=c.T[t];a.push(r())}));const t=await Promise.all(a),r=new Map;return e.forEach((({type:e},a)=>{r.set(e,t[a])})),r}(a),i=a.map((({id:e,type:a})=>new(n.get(a))({url:t,layerId:e,sourceJSON:r.find((({id:a})=>a===e))})));await Promise.allSettled(i.map((e=>e.load()))),i.forEach((a=>{const{layerId:t,loaded:r,defaultPopupTemplate:n}=a;if(!r||null==n)return;const i={id:t,popupInfo:n.toJSON()};"ArcGISFeatureLayer"!==a.operationalLayerType&&(i.layerType=a.operationalLayerType),T(a,i,e)}))}(e,d,r,p),e}(i,{url:t??"",customParameters:r,apiKey:n},e.map((e=>e.layer.layerId))));for(const a of e)T(a.layer,a.layerJSON,i);return i}function S(e,a,t){const n=(0,r.e5)(e,a,((e,a)=>e.id===a.id));e=e.filter((e=>!n.removed.some((a=>a.id===e.id))));const i=n.added;return i.forEach((({id:a})=>{e.push({id:a})})),{itemResources:e,added:i.filter((({id:e})=>!t.includes(e)))}}function T(e,a,t){e.isTable?N(t.tables,a):N(t.layers,a)}function N(e,a){const t=e.findIndex((({id:e})=>e===a.id));-1===t?e.push(a):e[t]=a}function O(e,a){if(!e.length)throw new n.Z(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function $(e,a){const t=e.map((e=>e.layerId));if(new Set(t).size!==t.length)throw new n.Z(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function U(e,a){const{url:t,layerId:r,title:n,fullExtent:i,isTable:l}=e,s=(0,o.Qc)(t);a.url="FeatureServer"===s?.serverType?t:`${t}/${r}`,a.title||=n,a.extent=null,l||null==i||(a.extent=await(0,d.$o)(i)),(0,d.ck)(a,d.Kz.METADATA),(0,d.ck)(a,d.Kz.MULTI_LAYER),(0,d.qj)(a,d.Kz.SINGLE_LAYER),l&&(0,d.qj)(a,d.Kz.TABLE)}async function x(e,a){return(0,l.a1)({layer:e,itemType:p,validateLayer:v,createItemData:(e,a)=>I(a,[e]),errorNamePrefix:m},a)}async function Z(e,a){await async function(e){O(e,h),await Promise.all(e.map((e=>e.load())));for(const a of e)(0,l.DC)(a,h,v),(0,l.Ym)({layer:a,itemType:p,errorNamePrefix:h});(function(e,a){const t=e.map((e=>e.portalItem.id));if(new Set(t).size>1)throw new n.Z(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")})(e,h),$(e,h)}(e);const t=e[0].portalItem,r=(0,y.Yv)(t),o=await Promise.all(e.map((e=>(0,l.Nw)(e,r,a)))),s=await I(t,e.map(((e,a)=>({layer:e,layerJSON:o[a]}))));return(0,l.UY)(t),await t.update({data:s}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),(0,i.D)(r),t.clone()}async function D(e,a,t){return(0,l.po)({layer:e,itemType:p,validateLayer:v,createItemData:(e,a)=>Promise.resolve(g(e)),errorNamePrefix:w,newItem:a,setItemProperties:U},t)}async function A(e,a,t){await async function(e){O(e,b),await Promise.all(e.map((e=>e.load())));for(const a of e)(0,l.DC)(a,b,v);(function(e,a){for(const t of e){const r=t.parsedUrl.path,i=(0,o.Qc)(r),s=i?.url.path;if(!s)throw new n.Z(`${a}:invalid-parameters`,(0,l.xG)(t,`has unsupported url pattern: ${r}`),{layer:t});const u=i?.serverType;if("FeatureServer"!==u&&"MapServer"!==u)throw new n.Z(`${a}:invalid-parameters`,(0,l.xG)(t,`has unsupported server type: ${u}`),{layer:t});if("MapServer"===u&&e.length>1)throw new n.Z(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=(0,o.Qc)(e[0].parsedUrl.path)?.url.path;if(!e.every((e=>(0,o.Qc)(e.parsedUrl.path)?.url.path===t)))throw new n.Z(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")})(e,b),$(e,b)}(e);const s=(0,l.uT)({itemType:p,errorNamePrefix:b,newItem:a}),u=(0,y.Yv)(s),c=await Promise.all(e.map((e=>(0,l.Nw)(e,u,t)))),f=await P(e.map(((e,a)=>({layer:e,layerJSON:c[a]}))));await async function(e,a){let t=0,n=0;for(const{isTable:e}of a)e?n++:t++;const i=a[0].parsedUrl.path,s=(0,o.Qc)(i);if(e.url="FeatureServer"===s?.serverType?s.url.path:i,e.title||=s.title,e.extent=null,t>0){const t=a.map((e=>e.fullExtent)).filter(r.pC).reduce(((e,a)=>e.clone().union(a)));t&&(e.extent=await(0,d.$o)(t))}(0,d.ck)(e,d.Kz.METADATA),(0,d.Ct)(e,d.Kz.MULTI_LAYER,a.length>1),(0,d.Ct)(e,d.Kz.SINGLE_LAYER,1===a.length),(0,d.Ct)(e,d.Kz.TABLE,n>0&&0===t),(0,l.UY)(e)}(s,e),await(0,l.jX)(s,f,t);for(const a of e)a.portalItem=s.clone();return(0,i.D)(u),s}},21011:(e,a,t)=>{t.d(a,{DC:()=>c,Nw:()=>w,UY:()=>h,Ym:()=>f,a1:()=>v,jX:()=>b,po:()=>L,uT:()=>m,xG:()=>d});var r=t(70375),n=t(50516),i=t(93968),l=t(53110),o=t(84513),s=t(31370),u=t(49278);function c(e,a,t){const n=t(e);if(!n.isValid)throw new r.Z(`${a}:invalid-parameters`,n.errorMessage,{layer:e})}async function y(e){const{layer:a,errorNamePrefix:t,validateLayer:r}=e;await a.load(),c(a,t,r)}function d(e,a){return`Layer (title: ${e.title}, id: ${e.id}) of type '${e.declaredClass}' ${a}`}function p(e){const{item:a,itemType:t,errorNamePrefix:n,layer:i,validateItem:l}=e;if((0,u.w)(a),a.type!==t)throw new r.Z(`${n}:portal-item-wrong-type`,`Portal item type should be "${t}"`,{item:a,layer:i});if(l){const e=l(a);if(!e.isValid)throw new r.Z(`${n}:invalid-parameters`,e.errorMessage,{layer:i})}}function f(e){const{layer:a,errorNamePrefix:t}=e,{portalItem:n}=a;if(!n)throw new r.Z(`${t}:portal-item-not-set`,d(a,"requires the portalItem property to be set"));if(!n.loaded)throw new r.Z(`${t}:portal-item-not-loaded`,d(a,"cannot be saved to a portal item that does not exist or is inaccessible"));p({...e,item:n})}function m(e){const{newItem:a,itemType:t}=e;let r=l.default.from(a);return r.id&&(r=r.clone(),r.id=null),r.type??=t,r.portal??=i.Z.getDefault(),p({...e,item:r}),r}async function w(e,a,t){"beforeSave"in e&&"function"==typeof e.beforeSave&&await e.beforeSave();const n=e.write({},a);return await Promise.all(a.resources?.pendingOperations??[]),function(e,a){let t=(e.messages??[]).filter((({type:e})=>"error"===e)).map((({name:e,message:a,details:t})=>new r.Z(e,a,t)));if(e.blockedRelativeUrls&&(t=t.concat(e.blockedRelativeUrls.map((e=>new r.Z("url:unsupported",`Relative url '${e}' is not supported`))))),a?.ignoreUnsupported&&(t=t.filter((({name:e})=>"layer:unsupported"!==e&&"symbol:unsupported"!==e&&"symbol-layer:unsupported"!==e&&"property:unsupported"!==e&&"url:unsupported"!==e))),t.length>0)throw new r.Z("layer-write:unsupported","Failed to save layer due to unsupported or invalid content. See 'details.errors' for more detailed information",{errors:t})}(a,t),n}function h(e){(0,s.qj)(e,s.Kz.JSAPI),e.typeKeywords&&(e.typeKeywords=e.typeKeywords.filter(((e,a,t)=>t.indexOf(e)===a)))}async function b(e,a,t){const r=e.portal;await r.signIn(),await(r.user?.addItem({item:e,data:a,folder:t?.folder}))}async function v(e,a){const{layer:t,createItemData:r,createJSONContext:i,saveResources:l}=e;await y(e),f(e);const s=t.portalItem,u=i?i(s):(0,o.Yv)(s),c=await w(t,u,a),d=await r({layer:t,layerJSON:c},s);return h(s),await s.update({data:d}),(0,n.D)(u),await(l?.(s,u)),s}async function L(e,a){const{layer:t,createItemData:r,createJSONContext:i,setItemProperties:l,saveResources:s}=e;await y(e);const u=m(e),c=i?i(u):(0,o.Yv)(u),d=await w(t,c,a),p=await r({layer:t,layerJSON:d},u);return await l(t,u),h(u),await b(u,p,a),t.portalItem=u,(0,n.D)(c),await(s?.(u,c)),u}},8308:(e,a,t)=>{t.d(a,{V:()=>n});var r=t(40371);async function n(e,a){const t=await(0,r.T)(e,a);c(t),o(t);const n={serviceJSON:t};if((t.currentVersion??0)<10.5)return n;const i=await(0,r.T)(e+"/layers",a);return c(i),o(i),n.layersJSON={layers:i.layers,tables:i.tables},n}function i(e){return"Feature Layer"===e.type||"Oriented Imagery Layer"===e.type}function l(e){return"Table"===e.type}function o(e){e.layers=e.layers?.filter(i),e.tables=e.tables?.filter(l)}function s(e){e.type||="Feature Layer"}function u(e){e.type||="Table"}function c(e){e.layers?.forEach(s),e.tables?.forEach(u)}},92557:(e,a,t)=>{t.d(a,{T:()=>r});const r={BingMapsLayer:async()=>(await t.e(1968).then(t.bind(t,31968))).default,BuildingSceneLayer:async()=>(await Promise.all([t.e(4328),t.e(8902),t.e(2546),t.e(9871)]).then(t.bind(t,59871))).default,CSVLayer:async()=>(await t.e(9849).then(t.bind(t,89849))).default,DimensionLayer:async()=>(await t.e(442).then(t.bind(t,10442))).default,ElevationLayer:async()=>(await Promise.all([t.e(9993),t.e(451)]).then(t.bind(t,90451))).default,FeatureLayer:async()=>(await Promise.resolve().then(t.bind(t,12926))).default,GeoJSONLayer:async()=>(await t.e(1655).then(t.bind(t,81655))).default,GeoRSSLayer:async()=>(await t.e(4417).then(t.bind(t,84417))).default,GroupLayer:async()=>(await t.e(2481).then(t.bind(t,82481))).default,ImageryLayer:async()=>(await Promise.all([t.e(8500),t.e(4733),t.e(3954),t.e(7082)]).then(t.bind(t,87082))).default,ImageryTileLayer:async()=>(await Promise.all([t.e(4733),t.e(8766),t.e(3954),t.e(6205)]).then(t.bind(t,10449))).default,IntegratedMeshLayer:async()=>(await Promise.all([t.e(8902),t.e(6479)]).then(t.bind(t,96479))).default,KMLLayer:async()=>(await t.e(711).then(t.bind(t,60711))).default,LineOfSightLayer:async()=>(await t.e(6498).then(t.bind(t,16498))).default,LinkChartLayer:async()=>(await Promise.all([t.e(3709),t.e(17),t.e(5818),t.e(693),t.e(8118)]).then(t.bind(t,91674))).default,MapImageLayer:async()=>(await Promise.all([t.e(8500),t.e(4269),t.e(8271),t.e(8806)]).then(t.bind(t,88806))).default,MapNotesLayer:async()=>(await t.e(9581).then(t.bind(t,29581))).default,MediaLayer:async()=>(await t.e(5882).then(t.bind(t,15882))).default,OGCFeatureLayer:async()=>(await t.e(3963).then(t.bind(t,53963))).default,OpenStreetMapLayer:async()=>(await t.e(3206).then(t.bind(t,33206))).default,OrientedImageryLayer:async()=>(await t.e(9855).then(t.bind(t,29855))).default,PointCloudLayer:async()=>(await t.e(3108).then(t.bind(t,73108))).default,RouteLayer:async()=>(await t.e(7731).then(t.bind(t,57731))).default,SceneLayer:async()=>(await Promise.all([t.e(4328),t.e(8902),t.e(2546),t.e(4606)]).then(t.bind(t,74606))).default,StreamLayer:async()=>(await t.e(5609).then(t.bind(t,75609))).default,SubtypeGroupLayer:async()=>(await t.e(4765).then(t.bind(t,14765))).default,TileLayer:async()=>(await Promise.all([t.e(8500),t.e(4269),t.e(9993),t.e(8271),t.e(5369)]).then(t.bind(t,75369))).default,UnknownLayer:async()=>(await t.e(81).then(t.bind(t,40081))).default,UnsupportedLayer:async()=>(await t.e(4864).then(t.bind(t,74864))).default,VectorTileLayer:async()=>(await Promise.all([t.e(2616),t.e(9993),t.e(3043),t.e(5520)]).then(t.bind(t,45520))).default,VoxelLayer:async()=>(await t.e(5519).then(t.bind(t,85519))).default,WFSLayer:async()=>(await t.e(4420).then(t.bind(t,84420))).default,WMSLayer:async()=>(await t.e(49).then(t.bind(t,30049))).default,WMTSLayer:async()=>(await t.e(9862).then(t.bind(t,69862))).default,WebTileLayer:async()=>(await t.e(9859).then(t.bind(t,89859))).default}},84513:(e,a,t)=>{t.d(a,{M4:()=>s,Yv:()=>l,ht:()=>i,wk:()=>o});var r=t(3466),n=t(93968);function i(e){return{origin:"portal-item",url:(0,r.mN)(e.itemUrl),portal:e.portal||n.Z.getDefault(),portalItem:e,readResourcePaths:[]}}function l(e){const a=(0,r.mN)(e.itemUrl);return{origin:"portal-item",messages:[],writtenProperties:[],url:a,portal:e.portal||n.Z.getDefault(),portalItem:e,verifyItemRelativeUrls:a?{rootPath:a.path,writtenUrls:[]}:null,blockedRelativeUrls:[]}}function o(e){return{origin:"web-map",url:(0,r.mN)(e.itemUrl),portal:e.portal||n.Z.getDefault(),portalItem:e,readResourcePaths:[]}}function s(e,a){const t=(0,r.mN)(e.itemUrl);return{origin:"web-map",messages:[],writtenProperties:[],url:t,portal:e.portal||n.Z.getDefault(),portalItem:e,initiator:a,verifyItemRelativeUrls:t?{rootPath:t.path,writtenUrls:[]}:null,blockedRelativeUrls:[],resources:{toAdd:[],toUpdate:[],toKeep:[],pendingOperations:[]}}}},40371:(e,a,t)=>{t.d(a,{T:()=>n});var r=t(66341);async function n(e,a){const{data:t}=await(0,r.Z)(e,{responseType:"json",query:{f:"json",...a?.customParameters,token:a?.apiKey}});return t}},49278:(e,a,t)=>{t.d(a,{w:()=>l});var r=t(51366),n=t(70375),i=t(99522);function l(e){if(r.Z.apiKey&&(0,i.r)(e.portal.url))throw new n.Z("save-api-key-utils:api-key-not-supported",`Saving is not supported on ${e.portal.url} when using an api key`)}}}]);